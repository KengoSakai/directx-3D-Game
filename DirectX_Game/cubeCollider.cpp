/******************************************************************
***
***		当たり判定直方体処理
***
***		cubeCollision.cpp
***
***		author: Kengo Sakai
***
*******************************************************************/

/******************************************************************
インクルードファイル
*******************************************************************/
#include "manager.h"
#include "renderer.h"
#include "cubeCollider.h"
/******************************************************************
マクロ定義
*******************************************************************/

/******************************************************************
構造体またはクラス定義
*******************************************************************/

/******************************************************************
プロトタイプ宣言
*******************************************************************/

/******************************************************************
グローバル変数
*******************************************************************/

/******************************************************************/

/******************************************************************
コンストラクタ
*******************************************************************/
CCubeCollider::CCubeCollider()
{

}

/******************************************************************
デストラクタ
*******************************************************************/
CCubeCollider::~CCubeCollider()
{

}

/******************************************************************
初期化処理関数
*******************************************************************/
void CCubeCollider::Initialize(void)
{
	//デバイス情報を取得
	LPDIRECT3DDEVICE9 pDevice = CManager::GetRenderer()->GetDevice();

	m_Pos = D3DXVECTOR3(0.0f,0.0f,0.0f);		//座標
	m_Wh = D3DXVECTOR3(10.0f,10.0f,10.0f);
	m_Rot = D3DXVECTOR3(0.0f,0.0f,0.0f);		//回転
	m_Scale = D3DXVECTOR3(1.0f,1.0f,1.0f);		//拡大率
	
	m_Material.Ambient= D3DXCOLOR(0.0f,0.0f,1.0f,1.0f);
	m_Material.Diffuse= D3DXCOLOR(0.0f,0.0f,0.0f,0.5f);
	m_Material.Emissive = D3DXCOLOR(0.0f,0.0f,0.0f,1.0f);
	m_Material.Specular = D3DXCOLOR(0.0f,0.0f,0.0f,1.0f);
	m_Material.Power = 0.0f;
		
	pDevice->SetMaterial(&m_Material);

	//ボックスを生成
	D3DXCreateBox(pDevice,m_Wh.x,m_Wh.y,m_Wh.z,&m_pMesh,NULL);
}

/******************************************************************
終了処理関数
*******************************************************************/
void CCubeCollider::Uninitialize(void)
{

}

/******************************************************************
更新処理関数
*******************************************************************/
void CCubeCollider::Update(void)
{

}

/******************************************************************
描画処理関数
*******************************************************************/
void CCubeCollider::Draw(void)
{
	SetMatrix();

	//描画関数呼び出し
	m_pMesh->DrawSubset(0);

}

/******************************************************************
オブジェクト生成処理関数
*******************************************************************/
CCubeCollider *CCubeCollider::Create(void)
{
	CCubeCollider *pCubeCollide;

	pCubeCollide = new CCubeCollider;

	pCubeCollide->Initialize();

	return pCubeCollide;
}

/******************************************************************
行列設定処理関数
*******************************************************************/
void CCubeCollider::SetMatrix(void)
{
	//デバイス情報を取得
	LPDIRECT3DDEVICE9 pDevice =  CManager::GetRenderer()->GetDevice();

	//単位行列
	D3DXMatrixIdentity(&m_mtxWorld);

	//拡大行列
	D3DXMatrixScaling(&m_mtxScale,m_Scale.x,m_Scale.y,m_Scale.z);

	//平行行列
	D3DXMatrixTranslation(&m_mtxTrans,m_Pos.x,m_Pos.y,m_Pos.z);

	//回転行列
	D3DXMatrixRotationYawPitchRoll(&m_mtxRot,
		D3DXToRadian(m_Rot.y),
		D3DXToRadian(m_Rot.x),
		D3DXToRadian(m_Rot.z));

	m_mtxWorld = m_mtxScale * m_mtxRot * m_mtxTrans;

	//ワールド変換
	pDevice->SetTransform(D3DTS_WORLD,&m_mtxWorld);
}
